#include <stdio.h>

16-16 구조체
(1-1)
구조체란, 하나 이상의 변수를 묶어서 좀 더 편리하게 사용할 수 있도록 도와주는 도구.
구조체 뒤에는 항상 ; 를 붙여줘야하므로 주의주의
ex ) struct 구조체 이름 { 구조체 멤버들} ;

typedef 를 이용하면 main 함수에서 구조체를 선선할 때 매번 struct 를 써줄 필요가 없습니다.
이 typedef 를 사용할 때에는 구조체 별칭이 필요한데, 구조체 별칭은 구조체를 정의할 때 중괄호 뒤에 써주면 됩니다.
코드를 보며 사용하는 방법을 알아보겠습니다(1-2)
구조체 별칭은 구조체 이름과 동일하게 써줘도 무관하지만, 일반적으로 구조체 이름과 별칭을 둘 다 쓸 떄는 구조체 이름 앞에 _를 붙여줍니다.
    
구조체 이름도 생략가능하다고 했던 것, 기억하시나요? 사실 사용하는건 별칭뿐인데 매번 구조체 이름까지 적는 것이 귀찮을 수 있습니다. typedef 를 쓰면 구조체 이름을 쓰지 않고 별칭만 사용하는 것도 가능합니다. 코드로 바로 살펴보겠습니다(1-3)
이와같이 구조체 이름을 굳이 적지 않아도 구조체를 선언하고 사용하는 것이 가능합니다. typedef 를 이용해 구조체 별칭을 사용할 때에도 문법은 똑같으므로 멤버에 접근할 떄는 똑같이 .을 이용하면 됩니다.

구조체 배열
일반 변수에 배열이 있듯이 구조체에도 배열이 있습니다.
학생 정보를 저장하는 구조체를 만들어서 수십 수백명의 정보를 저장해야 한다고 하면, 일반 변수처럼 구조체도 일일히 선언하는 것보다 배열을 쓰는 것이 훨씬 편리할 것입니다.
구조체 배열을 선언하는 방법은 배열을 선언하는 방법과 같은데,선언 및 초기화 하는 방법을 보도록 하겠습니다.(1-4)

구조체 포인터
포인터가 어떤 변수의 주소를 담아서 가리키는 변수라는 것은 기억하고 계시지요? 구조체 포인터도 마찬가지입니다. 구조체를 가리키는 포인터를 구조체 포인터라고 합니다. 하지만 구조체 포인터에서는 기억해야 할 점이 있습니다. int 형 포인터는 int &ptr; 형식으로 선언했었지요. 구조체는 struct [구조체 이름] 이 자료형이나 마찬가지입니다. 따라서 struct student *ptr; 과 같이 선언해야합니다. 이렇게 되면 앞에 struct 가 있으니 ptr 이 구조체라고 착각하시는 분들이 많은데, 이 ptr 은 구조체를 가리키는 포인터일뿐 절대 구조체가 아니라는 점 기억해주세요! 그럼 구조체 포인터를 선언하는 코드를 보도록 하겠습니다. (1-5)
위와 같이 구조체 포인터를 이용해서 값을 대입하고, 그 값을 이용할 수 있습니다. 여기서 주의해야 할 점은 포인터를 사용할 때 *ptr.age 처럼 바로 사용하는 것이 아니라 (*ptr).age 와 같이 괄호를 이용해야 한다는 것입니다.
포인터 챕터에서 *ptr++ 와 (*ptr)++ 의 차이점을 공부하신 분들은 짐작하시겠지만, 저 온점도 연산자의 일종입니다. 따라서 *ptr.age 를 이용하면 구조체가 아닌 포인터 변수를 구조체처럼 참조하려고 하기 때문에 오류가 발생합니다. 따라서 구조체 포인터를 사용하기 위해서는 항상 괄호를 사용해야 합니다.
그렇지만 매번 구조체 포인터를 사용할 때마다 괄호를 써주려면 매위 귀찮을 것 같지 않나요? C언어를 만든 프로그래머들도 똑같은 생각을 했습니다. 그래서 -> 라는 기호를 만들었습니다. 이 기호를 이용하면 괄호를 사용하지 않아도 알아서 주소로 찾아가서 구조체를 참조합니다. 괄호를 쓰지 않아도 되니 편리할 뿐만 아니라, 가독성도 더 좋습니다. 화살표 기호를 사용한 코드를 한번 볼까요?(1-6)
    괄호를 이용한 것과 마찬가지로 정상적으로 값이 대입되었습니다. 따라서 앞으로 구조체 포인터를 이용할 때는 이 화살표 기호를 이용하시면 됩니다. 물론 괄호쓰는 것이 더 편하다고 생각하시는 분들은 화살표 기호 대신 괄호를 이용하셔도 됩니다.
// 나는 도대체 포인터가 왜 중요한지 이해가 안되네..
다른 사이트 참고*
포인터를 사용함으로써 복사본을 만들지 않고 주소만 알려줌으로 해서 용량 및 처리시간에 이득을 볼 수 있습니다. 메모리가 한정적이거나 처리시간이 중요한 시스템에서 사용할 경우 도움이 되겠지요. 예를 들어 다음과 같은 코드가 있을 때 (0-1) 참고
main에서 abc_struct_1이라는 20000만개의 배열을 가진 거대한 구조체 변수를 만듭니다. 이 구조체에 있는 내용을 call_you 라는 함수에서 쓰기 위해 인자로 보내지면 abc_struct_1이라는 구조체 변수의 내용이 abc_struct_2라는 구조체 변수가 만들어지며넛 복사가 됩니다. 그럼 40000개의 배열이 메모리를 차지하게 되는 거지요... 포인터를 써서 abc_struct_1에 찾아가서 처리하라고 하면 추가로 20000개의 배열을 만들지 않고도 똑같은 일을 할 수 있습니다.
포인터 활용법은 이렇게 된다. 포인터 활용법을 알고 있으니 이제 공부가 더 잘 되겠다. 포인터가 매우 중요하다고 하는데 이제 왜 중요한지 알게 되었다.

중첩 구조체
구조체에서는 한가지 독특한 점을 볼 수 있습니다. 바로 구조체를 선언할 수 있다는 것입니다. 무슨 말인지 이해가 잘 안가실텐데, 코드를 먼저 보도록 하겠습니다.(1-7)
이런 식으로 다른 구조체를 멤버로 포함할 수 있습니다. 이럴 경우, Student안의 Teacher구조체를 이용하고 싶으면 Student.teahcer.age 와 같이 연속으로 멤버를 참조해야 사용할 수 있습니다. 물론 Teacher 구조체만 따로 선언해서 사용할 수도 있습니다.
    왜 굳이 구조체를 중첩으로 넣어서 복잡하게 만들지? 라고 생각하실 수도 있지만, 이런 식으로 구조체를 중첩하게 되면 여러가지 정보를 관리하기에 용이합니다. 예를 들어, 학교에는 학생마다 담임 선생님이 있을 것입니다. 그 담임 선생님의 정보를 학생 정보마다 넣고 싶을 경우, 위와 같이 학생 구조체 안에 선생님 구조체를 넣어서 관리할 수 있겠지요?
    그리고 구조체에는 한가지 더 복잡한 개념이 있습니다. 자기 참조 구조체 입니다.

자기 참고 구조체
구조체는 자기 자신을 참조하도록 자기와 똑같은 타입의 구조체를 멤버로 가질 수 있는데, 중첩 구조체보다 좀 더 복잡하게 느껴질 수 있습니다. 코드를 바로 보도록 하겠습니다.(1-8)
아직 구조체 선언이 끝나지도 않았는데, 어떻게 구조체 안에 또 구조체를 선언할 수 있지? 하고 의문이신 분들도 걔실 겁니다. 하지만 구조체에서는 위와 같이 자기 자신을 가리키는 포인터를 멤버로 가질 수 있습니다. 조금 복잡하긴 하지만, 그냥 int 형 구조체 안에 또 다른 int 형 포인터를 생성해주었다고 생각하면 좀 더 이해하기 편하실 겁니다.
    그런데 중첩 구조체처럼 어떠한 정보를 저장하는 것도 아니고, 자기 자신을 가리켜서 어디에 쓰는 걸까요? 아직 여러분들 단계에서는 모르셔도 괜찮습니다. 이렇게 자기 참고 구조체는 연결 리스트나 트리를 만들 떄 사용되는데, 이 연결리스트와 트리는 자료구조에서 나오는 내용입니다. C언어를 이제 막 배우는 여러분들은 이런 특성이 있구나, 하고 넘어가시면 됩니다.

구조체와 함수
함수를 배운 순간 부터 함수는 프로그램과 떨어질 수 없는 관계입니다. 프로그램의 코드가 길어질 수록 기능을 함수로 분리하는 것이 좋은데, 함수에서도 구조체를 사용할 일이 있겠지요? 구조체를 함수에 전달할 때는 어떤 식으로 사용하는지 알아봅시다.
    
구조체 전달
구조체를 인자(매개변수)로 전달할 때에는 두가지 방법이 있습니다. 포인터로 전달하는 것과, 구조체 그대로 전달하는 것이지요.
포인터 챕터에서 설명했듯이 포인터를 사용하지 않고 넘겨주게 되면 매개변수에 복사되는 것이므로 원본 값에는 영향을 끼치지 않습니다. 따라서 어떤 변수의 값을 가져와서 출력을 한다거나, 원본 값을 수정할 필요가 없는 경우에는 포인터를 사용하지 않고 그냥 복사해서 넘겨주었지요.
하지만 구조체의 경우는 조금 다릅니다. 구조체는 여러가지 자료형을 묶어서 새로운 자료형으로 만든 것이기 때문에, 구조체 크기가 커질 수록 복사할 공간이 더 필요하게 됩니다. 따라서 공간이 낭비되어 비효율적이기 때문에, 매개변수로 구조체를 전달할 때에는 보통 포인터를 사용합니다. 값을 바꿀 필요가 없는 경우에도요.
    그럼 먼저 포인터 없이 구조체를 인자(매개변수)로 전달하는 코드를 살펴봅시다.(1-9)
예상대로 printf_student 함수 내에서는 바뀐 값으로 출력되었지만, main 함수에서의 값은 바뀌지 않았기 때문에 두번째 출력에서는 원래의 값이 출력되었습니다.
    이제 포인터로 함수에 전달해 보겠습니다.(1-10)

17-17강 주사위 게임 만들어보기
다른 라이브러리 파일
이번 강의에서는 지금까지 배웠던 것을 토대로 간단한 게임을 만들게 됩니다. 게임을 만들기 위해서는 먼저 C 언어 표준 라이브러리 파일 중 두 가지를 불러오게 됩니다. 지금까지 사용했던 stdio.h 파일도 C 언어 표준 라이브러리 파일 중 하나입니다. stdio.h 파일에는 지금까지 썼던 printf, scanf 등 입출력 함수를 사용할 수 있게 된다고 말한 적이 있습니다.
이번 강의에서 사용할 파일은 stdlib.h 와 time.h 로 파일에 포함되어 있는 기능들을 이용하여 난수를 만들 떄 사용할 것입니다.
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
위와 같이 stdlib.h 파일을 stdio.h 아래에 선언해주는 것으로 라이브러리 파일을 불러올 수 있고, 지원하는 기능들을 사용할 수 있게 됩니다.
    
난수(랜덤) 만들기
앞에서 배웠던 위 두 가지 C 표준 라이브러리 파일을 이용하여 난수를 만드는 법을 배웁니다. 난수란 특정한 순서나 규칙을 가지지 않는 수로 무작위라고 생각하시면 됩니다.
난수를 만들 때 사용하는 함수로는 srand 와 rand 그리고 time 함수가 있습니다. srand 와 rand 함수는 stdlib.h 파일에 포함되어 있고, time 함수는 time.h 파일에 포함되어 있습니다.
- srand 는 호출할 때 전달받는 인자를 기반으로 해서 난수를 초기화 시켜줍니다.
- rand 는 srand 로 인해 생성된 값을 바탕으로 난수를 생성해줍니다.
- time 함수는 인자값으로 NULL 을 넘기면 1970년 1월 1일 0시 이후부터 인자값까지 현재까지 흐른 초 수를 리턴해줍니다.
시간은 멈추지 않고 계속해서 흐르므로 time 함수로 구한 초 수를 기반으로 srand 함수를 이용하여 난수 기준값을 초기화한 다음. rand 함수를 호출하면 시간을 기반으로한 지넞ㅇ한 무작위 숫자가 생성되게 됩니다.
srand 와 현재 시간을 가져오는 time 함수를 엮은 사용법입니다.
srand(time(NULL))
위 코드 한 줄을 rand 함수 호출 전에 선언하면 시간을 기준으로 초기화되는 진정한 난수를 만들어낼 수 있게 됩니다.
    
rand 함수 사용법
실제 난수를 생성해주는 rand 함수의 사용법에는 몇 가지가 있습니다. rand 함수를 호출하면 10자리 남짓한 랜덤한 숫자를 생성해주는데, 이 수를 이용하여 원하는 범위의 난수를 만들어낼 수 있습니다.
= rand() % n = 0 ~ n-1 범위의 난수를 생성합니다.
= (rand() % n ) + 1 = 1 ~ n 범위의 난수를 생성합니다.
위 두 가지만 알아두어도 주사위 게임을 만드는데는 충분합니다. 아래는 난수를 만드는 실제 코드입니다.(2-1예제)
    
주사위 게임 만들기 (상)
주사위 게임 만들기 (상)에서는 게임에 필요한 각종 필요한 변수들을 선언하고, 사용자로부터 입력을 받는 것까지 구현합니다. 사용자가 올바른 입력을 할 때까지 계속해서 묻는 것은 while 반복문을 이용하면 쉽게 구현할 수 있습니다.
    기본적인 변수를 같이 선언해보겠습니다.(2-2예제)
    이렇게 4 가지 변수를 선언했다면, 이제 본격적으로 게임을 만들어보도록 하겠습니다.

주사위 게임 만들기(중)
주사위 게임 만들기(중)에서는 사용자가 번호에 입력을 할 수 있도록 만듭니다. 이 입력은 정해진 번호를 입력할 때까지 계속해서 묻습니다. 그리고 주사위를 굴려서 나온 값(난수)를 플레이어와 컴퓨터 각자의 점수에 더합니다. 이 작업은 diceEnd 변수의 숫자만큼 반복합니다.
정리하면 이번 강의 문제는 다음과 같습니다.
- diceCount 변수가 diceEnd 변수의 값보다 작다면 계속해서 게임을 반복합니다 (while 문 이용)
- 사용자가 1번을 고르면 주사위를 던집니다. 2번을 눌렀을 때는 현재 점수를 확인합니다.
- 주사위를 던지면 rand 함수를 이용해 두 개의 난수(사용자,컴퓨터)를 만들고, 각자의 점수에 더해줍니다. 주사위를 굴렸다면 diceCount 를 증가시킵니다.
어느정도 기본틀을 만들어 놓았으니, 적절한 코드를 이용하여 이번 문제를 풀어보세요. 문제를 풀다 정 안되겠다면 주사위 게임 만들기(하)로 이동하여 코드를 확인해보도록 합시다. 되도록이면 자신의 힘으로 하는 것이 좋습니다.(2-3예제)

주사위 게임 만들기(하)
여기까지 완성ㅐ했다면 이제 마무리 작업만이 남았습니다. 게임은 잘 진행되고, 점수도 잘 쌓여가지만 결과창이 나오지가 않습니다. 게임의 결과를 알려주는 기능을 함수로 만들어 main 함수에서 호출해주세요.
- 함수의 이름은 showEnding 입니다.
- checkScore 처럼 mScore 와 cSore 변수를 인자로 받습니다.
- mScore 와 mScore 를 비교하여 승자를 가려냅니다.
- pirntf 를 이용해서 결과를 알려줍니다.
위 문제를 풀던 중 막혀서 도저히 나아가지 못하겠다면 다음 강의에서 답안을 확인해주세요. 되도록이면 자신의 힘으로 하는 것이 좋습니다.
